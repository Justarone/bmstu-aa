\chapter{Исследовательская часть}

%\section{Пример работы}

%Демонстрация работы программы приведена на рисунке \ref{img:levenshtein_demo}.

%\boximg{160mm}{levenshtein_demo}{Демонстрация работы алгоритмов нахождения расстояния Левенштейна и Дамерау -- Левенштейна}

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование:

\begin{itemize}
	\item Операционная система: Manjaro \cite{manjaro} Linux \cite{linux} x86\_64.
	\item Память: 8 GiB.
	\item Процессор: Intel® Core™ i7-8550U\cite{intel}.
\end{itemize}

Тестирование проводилось на ноутбуке, включенном в сеть электропитания. Во время тестирования ноутбук был нагружен только встроенными приложениями окружения, окружением, а также непосредственно системой тестирования.

\section{Время выполнения алгоритмов}

Алгоритмы тестировались при помощи написания <<бенчмарков>> \cite{rusttest}, предоставляемых встроенными в Rust средствами. Такие бенчмарки делают за нас некоторое кол-во замеров (достаточное, чтобы считать результат стабильным), предоставляя затем результат с некоторой погрешностью. Также мною были написаны тесты, прогоняющие алгоритмы $Z$ раз, где $Z$ можно выбирать.

В листинге \ref{lst:bench_example} пример реализации бенчмарка.

\begin{lstinputlisting}[
	caption={Пример бенчмарка},
	label={lst:bench_example},
	style={rust},
	]{inc/lst/ex.rs}
\end{lstinputlisting}

Результаты замеров приведены в таблице \ref{tbl:time}. В данной таблице для значений, для которых тестирование не выполнялось, в поле результата находится NaN.
На рисунках \ref{plt:time_levenshtein} и \ref{plt:time_dl} приведены графики зависимостей времени работы алгоритмов от длины строк.

\begin{table}[h]
	\begin{center}
		\caption{Замер времени для строк, размером от 10 до 200}
		\label{tbl:time}
		\begin{tabular}{|c|c|c|c|c|}
			\hline
			                      & \multicolumn{4}{c|}{\bfseries Время, нс}                                    \\ \cline{2-5}
			\bfseries Длина строк & \bfseries Recursive & \bfseries RecMem & \bfseries Iterative & \bfseries IterativeDL
			\csvreader{inc/csv/time.csv}{}
			{\\\hline \csvcoli&\csvcolii&\csvcoliii&\csvcoliv&\csvcolv}
			\\\hline
		\end{tabular}
	\end{center}
\end{table}

\begin{figure}[h]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
			axis lines=left,
			xlabel=Длина строк,
			ylabel={Время, нс},
			legend pos=north west,
			ymajorgrids=true
		]
			\addplot table[x=len,y=RecursiveMatrix,col sep=comma] {inc/csv/time_recmat.csv};
			\addplot table[x=len,y=IterativeMatrix,col sep=comma] {inc/csv/time_itmat.csv};
			\legend{Рекурсивный с матрицей, Матричный}
		\end{axis}
	\end{tikzpicture}
	\captionsetup{justification=centering}
	\caption{Зависимость времени работы алгоритма вычисления расстояния Левенштейна от длины строк (рекурсивная с заполнением матрицы и матричная реализации)}
	\label{plt:time_levenshtein}
\end{figure}

\begin{figure}[h]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
			axis lines=left,
			xlabel=Длина строк,
			ylabel={Время, нс},
			legend pos=north west,
			ymajorgrids=true
		]
			\addplot table[x=len,y=IterativeMatrix,col sep=comma] {inc/csv/time_itmat.csv};
			\addplot table[x=len,y=DamerauLevenshtein,col sep=comma] {inc/csv/time_dl.csv};
			\legend{Левенштейн, Д. — Левенштейн}
		\end{axis}
	\end{tikzpicture}
	\captionsetup{justification=centering}
	\caption{Зависимость времени работы матричных реализаций алгоритмов нахождения расстояний Левенштейна и Дамерау — Левенштейна}
	\label{plt:time_dl}
\end{figure}

\section{Использование памяти}

Алгоритмы нахождения расстояний Левенштейна и Дамерау — Левенштейна не отличаются друг от друга с точки зрения использования памяти, следовательно, достаточно рассмотреть лишь разницу рекурсивной и матричной реализаций этих алгоритмов.

Максимальная глубина стека вызовов при рекурсивной реализации равна сумме длин входящих строк, при этом для каждого вызова рекурсии в моей реализации требуется:
\begin{itemize}
    \item 4 локальные перeменные беззнакового типа, в моем случае: $4 \cdot 8 = 32$ байта;
    \item 2 аргумента типа строка: $2 \cdot 16 = 32$ байта;
    \item адрес возврата: 8 байт;
    \item место для записи возвращаемого функцией значения: 8 байт.
\end{itemize}
Таким образом получается, что при обычной рекурсии на один вызов требуется (\ref{for:onecall}): 

\begin{equation}
M_{per call} = 32 + 32 + 8 + 8 = 80 байт
\label{for:onecall}
\end{equation}

Следовательно память, расходуемая в момент, когда стек вызовов максимален, равна (\ref{for:rec}): 

\begin{equation}
    M_{recursive} = 80 \cdot depth
\label{for:rec}
\end{equation}

где \textit{depth} - максимальная глубина стека вызовов, которая равна (\ref{for:depth}):

\begin{equation}
depth = |S_1| + |S_2|
\label{for:depth}
\end{equation}

где $S_1, S_2$ - строки.

Если мы используем рекурсивный алгоритм с заполнением матрицы матрицы, то для каждого вызова рекурсии добавляется новый аргумент - ссылка на матрицу - размером $8$ байт. Также в данном алгоритме требуется память на саму матрицу, размеры которой: $m = |S_1| + 1, n = |S_2| + 1$. Размер элемента матрицы равен размеру беззнакового целого числа, используемого в моей реализации, то есть $8$ байт. Отсюда выходит, что память, которая тратится на хранение матрицы (\ref{for:matrix}):
\begin{equation}
M_{Matrix} = (|S_1| + 1) \cdot (|S_2| + 1) \cdot 8
\label{for:matrix}
\end{equation}

Таким образом, при рекурсивной реализации требуемая память равна (\ref{for:rec_mem}):
\begin{equation}
M_{recursive} = 88 \cdot depth + M_{Matrix}
\label{for:rec_mem}
\end{equation}
где $M_{Matrix}$ взято из соотношения \ref{for:matrix}.

Память, требуемая для при итеративной реализации, состоит из следующего:
\begin{itemize}
    \item 4 локальные перeменные беззнакового типа, в моем случае: $4 \cdot 8 = 32$ байта;
    \item 2 аргумента типа строка: $2 \cdot 16 = 32$ байта;
    \item адрес возврата: 8 байт;
    \item место для записи возвращаемого функцией значения: 8 байт;
    \item матрица: $M_{Matrix}$ из соотношения \ref{for:matrix}.
\end{itemize}

Таким образом общая расходуемая память итеративных алгоритмов (\ref{for:iter}):

\begin{equation}
M_{iter} = M_{Matrix} + 80
\label{for:iter}
\end{equation}

где $M_{Matrix}$ определяется из соотношения \ref{for:matrix}.


\section*{Вывод}

Рекурсивный алгоритм нахождения расстояния Левенштейна работает на порядок дольше итеративных реализаций, время его работы увеличивается в геометрической прогрессии. На словах длиной 10 символов, матричная реализация алгоритма нахождения расстояния Левенштейна превосходит по времени работы рекурсивную на несколько порядков. Рекурсивный алгоритм с заполнением матрицы превосходит простой рекурсивный и сравним по времени работы с матричными алгоритмами. Алгоритм нахождения расстояния Дамерау — Левенштейна по времени выполнения сопоставим с алгоритмом нахождения расстояния Левенштейна. В нём добавлена дополнительная проверка, позволяющая находить ошибки пользователя, связанные с неверным порядком букв, в связи с чем он работает незначительно дольше, чем алгоритм нахождения расстояния Левенштейна.

Но по расходу памяти итеративные алгоритмы проигрывают рекурсивному: максимальный размер используемой памяти в них растёт как произведение длин строк, в то время как у рекурсивного алгоритма — как сумма длин строк.
